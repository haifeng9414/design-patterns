# 设计模式学习

## 理论
- SOLID原则
  1. 单一职责原则（SRP，Single Responsibility Principle）：一个类或者模块只负责完成一个职责（或者功能）。当发生下面的情况时，可能就需要考虑一个类是否满足单一责任原则。当然这些只是主观上的判断，需要结合实际项目分析才能确定，并且项目本身是会变化的，所以这些情况也是不断变化的，实际实现项目时需要持续重构。
     1. 类中的代码行数、函数或者属性过多
     2. 类依赖的其他类过多
     3. 私有方法过多
     4. 比较难给类起一个合适的名字
     5. 类中大量的方法都是集中操作类中的某几个属性
  2. 开闭原则（OCP，Open Closed Principle）：对扩展开放、对修改关闭。通俗点说就是添加一个新的功能应该时，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等），即对扩展开放是为了应对需求的变化，对修改关闭是为了保证已有代码的稳定性。满足开闭原则的代码能够提供很好的扩展性。实际写代码时，多花点时间思考未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上。在识别出代码可变部分和不可变部分之后，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。
  3. 里式替换原则（LSP，Liskov Substitution Principle）：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。里式替换原则和多态的区别是，多态只是面向对象编程的一大特性，对子类的实现没有特殊要求，而里式替换原则要求子类替换父类时不能破坏程序原本的正确性，如某处使用父类的地方改用子类后，子类抛出异常就破坏了程序的正确性，里式替换原则另外一层含义是：按照协议来设计，即子类在设计的时候，要遵守父类的行为约定。`  这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
  4. 接口隔离原则（ISP，Interface Segregation Principle）：客户端不应该被强迫依赖它不需要的接口。对于接口，可以有下面三种理解：
     1. 一组方法集合，如某个Service的所有方法。如果这个Service被多个系统使用，但是其中某些方法只被部分系统使用，则这部分方法应该隔离出来。如UserService方法有注册、登录和获取信息等方法，这些方法各个模块都会使用，但是如果此时增加一个删除用户方法，由于该方法比较敏感，只允许被后台系统使用，此时应该将删除用户方法隔离到另一个接口，UserServiceImpl同时实现UserService和删除用户接口，普通模块注入UserService，后台系统注入UserService和删除用户接口，以此达到限制普通模块删除用户的能力。
     2. 单个API接口或函数。如果某些客户端只需要函数的部分功能，则应该将函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。如count方法返回Statistics对象，该对象包含了max、min、sum、average等统计结果，如果客户端需要所有结果，则可以直接返回Statistics对象，但是如果客户端只是部分需要这些结果，则可以将max、min、sum、average等统计结果分别放到单独的函数中实现。
     3. Java中的接口。对于Java接口，设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。如项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，分别设计实现了三个 Configuration类：RedisConfig、MysqlConfig、KafkaConfig。现在有一个新的功能需求，希望支持Redis和Kafka配置信息的热更新。所谓热更新就是如果在配置中心中更改了配置信息，则希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是RedisConfig、KafkaConfig类中）。但是，因为某些原因，不希望对MySQL的配置信息进行热更新。为了实现这样一个功能需求，定义一个Updater接口，指定了update()方法，并设计实现了一个ScheduledUpdater类，以固定时间频率来调用RedisConfig、KafkaConfig的update()方法更新配置信息。之后又有了一个新的监控功能需求，希望能有一种方便的方式查看配置信息。为了实现这个需要，在项目中开发一个内嵌的SimpleHttpServer，输出项目的配置信息到一个固定的HTTP地址。出于某些原因，我们只想暴露MySQL和Redis的配置信息，不想暴露Kafka的配置信息，此时同样定义一个Viewer接口，指定了输出信息的方法。现在设计了两个功能非常单一的接口：Updater和Viewer。ScheduledUpdater只依赖Updater这个跟热更新相关的接口，不需要被强迫去依赖不需要的Viewer接口，满足接口隔离原则。同理，SimpleHttpServer只依赖跟查看信息相关的Viewer接口，不依赖不需要的Updater接口，也满足接口隔离原则。这样做的好处是，使得代码更加灵活、易扩展、易复用。比如，现在又有一个新的需求，开发一个Metrics性能统计模块，并且希望将Metrics也通过 SimpleHttpServer显示在网页上，以方便查看。这个时候，尽管Metrics跟RedisConfig等没有任何关系，但仍然可以让Metrics类实现非常通用的Viewer接口，复用SimpleHttpServer的代码实现。另外接口隔离原则也避免了代码做一些无用功。比如如果不满足接口隔离原则，把上面提到的所有方法放到一个公共接口，RedisConfig、MysqlConfig、KafkaConfig都实现了这个接口，这会导致不需要实现热更新的MysqlConfig也需要实现热更新功能，或者写一个空方法，如果使用接口隔离原则就不会有这个问题。
  5. 依赖反转原则（DIP，Dependency Inversion Principle）：高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。以Tomcat这个Servlet容器为例，Tomcat是运行Java Web应用程序的容器。编写的Web应用程序代码只需要部署在Tomcat容器下，便可以被Tomcat容器调用执行。按照之前的划分原则，Tomcat就是高层模块，编写的Web应用程序代码就是低层模块。Tomcat和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是Sevlet规范。Servlet规范不依赖具体的Tomcat容器和应用程序的实现细节，而Tomcat容器和应用程序依赖Servlet规范。

